package es.santander.branchlocator;

import android.content.Context;
import android.location.Address;
import android.location.Geocoder;
import android.text.TextUtils;
import android.util.Log;
import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.Projection;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.MarkerOptions;
import com.google.android.gms.maps.model.VisibleRegion;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import javax.net.ssl.SSLException;

class BLMapUtils {
    private static final String TAG = "MapUtils";

    BLMapUtils() {
    }

    public static void addAllMarkersToMap(GoogleMap map, List<MarkerOptions> markerOptions) {
        for (MarkerOptions marker : markerOptions) {
            if (marker.getPosition() != null) {
                map.addMarker(marker);
            }
        }
    }

    public static List<MarkerOptions> generateMarkersFromBranchLocations(List<BLLocation> locations) {
        List<MarkerOptions> markers = new ArrayList<>();
        for (BLLocation location : locations) {
            if (location.getGeoCoordinate() != null) {
                markers.add(new MarkerOptions().position(new LatLng(location.getGeoCoordinate().getLatitude(), location.getGeoCoordinate().getLongitude())));
            }
        }
        return markers;
    }

    public static List<MarkerOptions> generateMarkers(int numMarkers) {
        List<MarkerOptions> markers = new ArrayList<>();
        for (int i = 0; i < numMarkers; i++) {
            MarkerOptions marker = new MarkerOptions();
            marker.position(generateRandomLatLng());
            marker.title("AutoGenerated");
        }
        return markers;
    }

    public static LatLng generateRandomLatLng() {
        Random r = new Random();
        return new LatLng((double) (r.nextInt(5) + 50), (double) (r.nextInt(5) + 45));
    }

    public static LatLng searchLocationFromString(Context context, String textLocation) {
        return searchLocationFromString(new Geocoder(context), textLocation);
    }

    private static LatLng searchLocationFromString(Geocoder geocoder, String textLocation) {
        if (TextUtils.isEmpty(textLocation)) {
            return null;
        }
        List<Address> addressList = null;
        try {
            addressList = geocoder.getFromLocationName(textLocation, 1);
        } catch (IOException e) {
            Log.e(TAG, e.toString());
        }
        if (addressList == null || addressList.size() <= 0) {
            return null;
        }
        Address address = addressList.get(0);
        return new LatLng(address.getLatitude(), address.getLongitude());
    }

    public static float distanceBetweenPoints(LatLng latLng1, LatLng latLng2) {
        LatLng latLng = latLng1;
        LatLng latLng3 = latLng2;
        double latDiff = Math.toRadians(latLng3.latitude - latLng.latitude);
        double lngDiff = Math.toRadians(latLng3.longitude - latLng.longitude);
        double a = (Math.sin(latDiff / 2.0d) * Math.sin(latDiff / 2.0d)) + (Math.cos(Math.toRadians(latLng.latitude)) * Math.cos(Math.toRadians(latLng3.latitude)) * Math.sin(lngDiff / 2.0d) * Math.sin(lngDiff / 2.0d));
        return new Float((((double) 1609) * (3958.75d * (Math.atan2(Math.sqrt(a), Math.sqrt(1.0d - a)) * 2.0d))) / 1000.0d).floatValue();
    }

    public static String getDirectionsUrl(LatLng origin, LatLng dest, Context context) {
        String str_origin = "origin=" + origin.latitude + "," + origin.longitude;
        String str_dest = "destination=" + dest.latitude + "," + dest.longitude;
        return "https://maps.googleapis.com/maps/api/directions/" + "json" + "?" + (str_origin + "&" + str_dest + "&" + "sensor=false" + "&" + "mode=walking" + "&" + ("key=" + context.getString(R.string.maps_api_key)));
    }

    public static String downloadUrl(String strUrl) throws IOException {
        String data = "";
        InputStream iStream = null;
        HttpURLConnection urlConnection = null;
        try {
            urlConnection = (HttpURLConnection) new URL(strUrl).openConnection();
            urlConnection.connect();
            iStream = urlConnection.getInputStream();
            BufferedReader br = new BufferedReader(new InputStreamReader(iStream));
            StringBuilder sb = new StringBuilder();
            while (true) {
                String readLine = br.readLine();
                String line = readLine;
                if (readLine == null) {
                    break;
                }
                sb.append(line);
            }
            data = sb.toString();
            br.close();
        } catch (SSLException e) {
            Log.e(TAG, e.toString());
        } catch (Exception e2) {
            Log.e(TAG, e2.toString());
        } catch (Throwable th) {
            iStream.close();
            urlConnection.disconnect();
            throw th;
        }
        iStream.close();
        urlConnection.disconnect();
        return data;
    }

    public static boolean poisInVisibleMap(List<BLPoi> pois, Projection projection) {
        if (pois == null || pois.size() <= 0) {
            return false;
        }
        VisibleRegion visibleRegion = projection.getVisibleRegion();
        for (BLPoi poi : pois) {
            if (visibleRegion.latLngBounds.contains(poi.getLatLng())) {
                return true;
            }
        }
        return false;
    }
}
